{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-jsx","path":"/flutter-state-managements/","result":{"data":{"markdownRemark":{"html":"<ul>\n<li>플러터의 상태 관리 라이브러리는 provider, getX, bloc가 대표적이다. 하나씩 살펴보자.</li>\n<li>프로젝트를 직접 만들어서 잘 적용되는 지 살펴보자.</li>\n</ul>\n<blockquote>\n<p>provider</p>\n</blockquote>\n<p>프로바이더는 플러터 공식 문서에서 소개된다. model, provider, consumer로 구분된다.</p>\n<ul>\n<li>\n<p>model은 전역 상태의 값과 값을 변경하는 비지니스 로직이 포함되었다. (class 로 작성되어 객체 지향이나 mobX에 익숙한 사람들이 사용하기 좋다. 이때 ChangeNotifier 클래스를 상속 받아 작성한다. 상태가 변경되면 provider가 이를 감지하게 된다.)</p>\n</li>\n<li>\n<p>provider는 ChangeNotifierProver 함수를 이용하며, runApp 안에 등록한다. provider가 많을 경우 MultiProvider로 감싸서 전역 상태들 모두 저장할 수 있다. 하지만 만약 전역 상태가 너무 많아진다면, 어떻게 관리해야할까? 이를 생각해봐야 한다.</p>\n</li>\n<li>\n<p>consumer는 사용하고자 하는 곳에서 기입하는 위젯이다.</p>\n</li>\n</ul>\n<p>간략히 살펴본 결과, react의 context-api와 유사함을 알 수 있다.</p>\n<blockquote>\n<p>getX</p>\n</blockquote>\n<blockquote>\n<p>bloc(business logic of component)</p>\n</blockquote>\n<ul>\n<li>bloc는 보일러플레이트가 많다는 평가를 읽어보았는데, 그럼에도 기존의 provider는 두고 등장한 것에는 이유가 있다고 생각한다. 자세히 살펴보도록 하자.</li>\n</ul>\n<p>bloc는 Presentation, Bussiness Logic, Data (Repository, Provider)로 나뉜다.</p>\n<p>큐빗(cubit) - react의 recoil의 atom 유사하다고 보여진다.</p>\n<ul>\n<li>bloc를 알기 위해서는 streams를 알아야 한다.</li>\n</ul>","frontmatter":{"date":"February 23, 2023","slug":"/flutter-state-managements","title":"플러터의 상태 관리 라이브러리들"}}},"pageContext":{"id":"f044238b-b048-5733-85b8-bd557319dd0f","frontmatter__slug":"/flutter-state-managements","__params":{"frontmatter__slug":"flutter-state-managements"}}},"staticQueryHashes":[],"slicesMap":{}}